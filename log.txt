2017.10.03
main.cpp	==> line. 72 이후 함수 호출을, 인공지능 두개로 변경
		-  함수 정보 (변경 내용, 주석이 변경 전)
coordinator.SetParticipants({
        
	CreateParticipant(Util::GetRaceFromString(botRaceString), &bot),
		
	CreateParticipant(Util::GetRaceFromString(enemyRaceString), &enemybot)
     
	//   CreateComputer(Util::GetRaceFromString(enemyRaceString))
    
});

TechTree.cpp	==> initUnitTypeData() 함수 내
		- m_upgradeData[0] = TypeData(); 을 m_unitTypeData[0] = TypeData(); 로 수정
		==> const TypeData & TechTree::getData(const sc2::UpgradeID & type)  const 함수 내
		- return m_unitTypeData.at(0); 을 return m_upgradeData.at(0); 로 수정


**참고 : 특정 종족에 대한 전략 만들고 싶다면, UseEnemySpecificStrategy를 Strategy 안에(StManager 122 참조)

stManager.cpp line 164~
		==> 전략 반복 진행 하기 위한 부분 (아직 미작성)

2017.10.04
** 동작 원리 분석 : onStart 실행 후, onFrame이 반복 실행. (스레드 형태로 반복 콜을 하는듯)
** 반복생산은 BuildOrderQueue 에서 m_queue가 비면 다시 실행시키는 방식으로?
	--> 그 위치는 아마도 ProductionManager.cpp 의 line 50, manageBuildOrderQueue() 함수 내

** Utill.cpp의 line 218
bool Util::IsCombatUnitType(const sc2::UnitTypeID & type, CCBot & bot)
{
    
	if (IsWorkerType(type)) { return true; }
    
	if (IsSupplyProviderType(type)) { return false; }
    
	if (bot.Data(type).isBuilding) { return false; }

 
   
	if (type == sc2::UNIT_TYPEID::ZERG_EGG) { return false; }
    
	if (type == sc2::UNIT_TYPEID::ZERG_LARVA) { return false; }

  
  
	return true;

}
첫번째, 일꾼의 타입을 true로 변경했더니, 정찰해온 일꾼들을 공격함. 그렇지만 진짜 공격유닛은 공격하지 않는다.


2017.10.6
StrategyManager 헤더와 소스 수정 중.
onFrame에 반복생산 구문을 넣기 위해, 변수 재조정 필요
==> 아니엇음, ProductionManager.cpp line 50~ manageBuildOrderQueue() 함수 내에서 동작 실험 (ProductionManager의 onFrame()에서 호출되는 함수)
// if there is nothing in the queue, oh well
    if (m_queue.isEmpty())
    {
		setBuildOrder(m_bot.Strategy().getOpeningBookBuildOrder());
        return;
    }


** 대부분의 로직이 존재하는 클래스는 CCBot을 가지고 있음

// 다음 과제, 유닛이 모이기 전에 공격가는거 안하도록 혹은 일꾼의 공격성을 줄이되, 정찰온 일꾼은 방어하는 형식으로

** 적 정찰을 방어하기
- 일꾼의 공격성을 제거하였을 경우, 공격 유닛이 없었다면, ScoutDefenseSquad가 형성이 안됨.
- 그렇기 때문에 기지가 부셔질 때까지 방치하는것.
- 대안 ; 공격 유닛이 없다면, 일꾼 하나를 공격 유닛으로 넣는다?

* CombatCommander의 enemyUnitsInRegion은 매우 중요 (내 영역 안의 적의 수를 파악할 수 있다.)

** 적 정찰 일꾼으로 방어하기
- 이전에 했던, 일꾼의 공격성 false로 되돌리기 (Util.cpp)
CombatCommander.cpp 의 line 110~ updateScoutDefenseSquad() 함수 내
- if (m_combatUnits.empty()) 구문 블럭
- line 147
//        UnitTag workerDefenderTag = findClosestWorkerTo(m_combatUnits, enemyWorkerUnit->pos);
		UnitTag workerDefenderTag = findClosestWorkerTo(enemyWorkerUnit->pos);
입력 변수 수정. (m_combatUnits 의 필요성을 못느낌. 아마도 실수일 거라 생각)

CombatCommander.h 함수 정보 변경
 UnitTag         findClosestDefender(const Squad & defenseSquad, const sc2::Point2D & pos);
//    UnitTag         findClosestWorkerTo(std::vector<UnitTag> & unitsToAssign, const sc2::Point2D & target);


이에 맞추어서 함수 정보 또한 변경 (CombatCommander.cpp line 446 for문)
   // for (auto & unitTag : unitsToAssign)
	for(auto & unitTag : m_bot.UnitInfo().getUnits(Players::Self))



- 함수 정리	updateScoutDefenseSquad()
	// if there's an enemy worker in our region then assign someone to chase him
	bool assignScoutDefender = (enemyUnitsInRegion.size() == 1) && Util::IsWorker(*m_bot.GetUnit(enemyUnitsInRegion[0]));
함수 앞쪽으로 이동



- updateScoutDefenseSquad() 함수 내, 정찰병 제재 유닛 선정 방식
 ( 병력이 없는 경우, 병력이 있는 경우 )
		UnitTag workerDefenderTag;
		if (m_combatUnits.empty())
		{
			// get our worker unit that is mining that is closest to it
			//        UnitTag workerDefenderTag = findClosestWorkerTo(m_combatUnits, enemyWorkerUnit->pos);
			workerDefenderTag = findClosestWorkerTo(enemyWorkerUnit->pos);
		}
		else
		{
			workerDefenderTag = findClosestCombatTo(m_combatUnits, enemyWorkerUnit->pos);
		}
수정

==> 새로운 findClosestCombatTo() 함수
UnitTag CombatCommander::findClosestCombatTo(std::vector<UnitTag> & unitsToAssign, const sc2::Point2D & target)
{
	UnitTag ret = 0;
	float closestDist = std::numeric_limits<float>::max();

	// for each of our workers
	// for (auto & unitTag : unitsToAssign)
	for (auto & unitTag : unitsToAssign)
	{
		auto unit = m_bot.GetUnit(unitTag);
		BOT_ASSERT(unit, "unit to assign was null");

		float dist = Util::Dist(unit->pos, target);

		if (dist < closestDist)
		{
			ret = unitTag;
			dist = closestDist;
		}
	}

	return ret;
}



******** 실험중 에러 발생
!Assert:   builderUnit
File:      c:\users\xonao\dropbox\sc2\commandcenter-master\commandcenter-master\src\buildingmanager.cpp
Message:   null builder unit
Line:      152
Time:      06-10-2017 21-07-48

*******************


다음 과제 ; 위 에러 확인 / 빌드 확립 / 두개의 프로젝트로 구분(나의 빌드/ 상대 빌드 )