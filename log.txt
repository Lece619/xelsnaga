2017.10.03
main.cpp	==> line. 72 이후 함수 호출을, 인공지능 두개로 변경
		-  함수 정보 (변경 내용, 주석이 변경 전)
coordinator.SetParticipants({
        
	CreateParticipant(Util::GetRaceFromString(botRaceString), &bot),
		
	CreateParticipant(Util::GetRaceFromString(enemyRaceString), &enemybot)
     
	//   CreateComputer(Util::GetRaceFromString(enemyRaceString))
    
});

TechTree.cpp	==> initUnitTypeData() 함수 내
		- m_upgradeData[0] = TypeData(); 을 m_unitTypeData[0] = TypeData(); 로 수정
		==> const TypeData & TechTree::getData(const sc2::UpgradeID & type)  const 함수 내
		- return m_unitTypeData.at(0); 을 return m_upgradeData.at(0); 로 수정


**참고 : 특정 종족에 대한 전략 만들고 싶다면, UseEnemySpecificStrategy를 Strategy 안에(StManager 122 참조)

stManager.cpp line 164~
		==> 전략 반복 진행 하기 위한 부분 (아직 미작성)

2017.10.04
** 동작 원리 분석 : onStart 실행 후, onFrame이 반복 실행. (스레드 형태로 반복 콜을 하는듯)
** 반복생산은 BuildOrderQueue 에서 m_queue가 비면 다시 실행시키는 방식으로?
	--> 그 위치는 아마도 ProductionManager.cpp 의 line 50, manageBuildOrderQueue() 함수 내

** Utill.cpp의 line 218
bool Util::IsCombatUnitType(const sc2::UnitTypeID & type, CCBot & bot)
{
    
	if (IsWorkerType(type)) { return true; }
    
	if (IsSupplyProviderType(type)) { return false; }
    
	if (bot.Data(type).isBuilding) { return false; }

 
   
	if (type == sc2::UNIT_TYPEID::ZERG_EGG) { return false; }
    
	if (type == sc2::UNIT_TYPEID::ZERG_LARVA) { return false; }

  
  
	return true;

}
첫번째, 일꾼의 타입을 true로 변경했더니, 정찰해온 일꾼들을 공격함. 그렇지만 진짜 공격유닛은 공격하지 않는다.


2017.10.6
StrategyManager 헤더와 소스 수정 중.
onFrame에 반복생산 구문을 넣기 위해, 변수 재조정 필요
==> 아니엇음, ProductionManager.cpp line 50~ manageBuildOrderQueue() 함수 내에서 동작 실험 (ProductionManager의 onFrame()에서 호출되는 함수)
// if there is nothing in the queue, oh well
    if (m_queue.isEmpty())
    {
		setBuildOrder(m_bot.Strategy().getOpeningBookBuildOrder());
        return;
    }


** 대부분의 로직이 존재하는 클래스는 CCBot을 가지고 있음

// 다음 과제, 유닛이 모이기 전에 공격가는거 안하도록 혹은 일꾼의 공격성을 줄이되, 정찰온 일꾼은 방어하는 형식으로

** 적 정찰을 방어하기
- 일꾼의 공격성을 제거하였을 경우, 공격 유닛이 없었다면, ScoutDefenseSquad가 형성이 안됨.
- 그렇기 때문에 기지가 부셔질 때까지 방치하는것.
- 대안 ; 공격 유닛이 없다면, 일꾼 하나를 공격 유닛으로 넣는다?

* CombatCommander의 enemyUnitsInRegion은 매우 중요 (내 영역 안의 적의 수를 파악할 수 있다.)

** 적 정찰 일꾼으로 방어하기
- 이전에 했던, 일꾼의 공격성 false로 되돌리기 (Util.cpp)
CombatCommander.cpp 의 line 110~ updateScoutDefenseSquad() 함수 내
- if (m_combatUnits.empty()) 구문 블럭
- line 147
//        UnitTag workerDefenderTag = findClosestWorkerTo(m_combatUnits, enemyWorkerUnit->pos);
		UnitTag workerDefenderTag = findClosestWorkerTo(enemyWorkerUnit->pos);
입력 변수 수정. (m_combatUnits 의 필요성을 못느낌. 아마도 실수일 거라 생각)

CombatCommander.h 함수 정보 변경
 UnitTag         findClosestDefender(const Squad & defenseSquad, const sc2::Point2D & pos);
//    UnitTag         findClosestWorkerTo(std::vector<UnitTag> & unitsToAssign, const sc2::Point2D & target);


이에 맞추어서 함수 정보 또한 변경 (CombatCommander.cpp line 446 for문)
   // for (auto & unitTag : unitsToAssign)
	for(auto & unitTag : m_bot.UnitInfo().getUnits(Players::Self))



- 함수 정리	updateScoutDefenseSquad()
	// if there's an enemy worker in our region then assign someone to chase him
	bool assignScoutDefender = (enemyUnitsInRegion.size() == 1) && Util::IsWorker(*m_bot.GetUnit(enemyUnitsInRegion[0]));
함수 앞쪽으로 이동



- updateScoutDefenseSquad() 함수 내, 정찰병 제재 유닛 선정 방식
 ( 병력이 없는 경우, 병력이 있는 경우 )
		UnitTag workerDefenderTag;
		if (m_combatUnits.empty())
		{
			// get our worker unit that is mining that is closest to it
			//        UnitTag workerDefenderTag = findClosestWorkerTo(m_combatUnits, enemyWorkerUnit->pos);
			workerDefenderTag = findClosestWorkerTo(enemyWorkerUnit->pos);
		}
		else
		{
			workerDefenderTag = findClosestCombatTo(m_combatUnits, enemyWorkerUnit->pos);
		}
수정

==> 새로운 findClosestCombatTo() 함수
UnitTag CombatCommander::findClosestCombatTo(std::vector<UnitTag> & unitsToAssign, const sc2::Point2D & target)
{
	UnitTag ret = 0;
	float closestDist = std::numeric_limits<float>::max();

	// for each of our workers
	// for (auto & unitTag : unitsToAssign)
	for (auto & unitTag : unitsToAssign)
	{
		auto unit = m_bot.GetUnit(unitTag);
		BOT_ASSERT(unit, "unit to assign was null");

		float dist = Util::Dist(unit->pos, target);

		if (dist < closestDist)
		{
			ret = unitTag;
			dist = closestDist;
		}
	}

	return ret;
}



******** 실험중 에러 발생
!Assert:   builderUnit
File:      c:\users\xonao\dropbox\sc2\commandcenter-master\commandcenter-master\src\buildingmanager.cpp
Message:   null builder unit
Line:      152
Time:      06-10-2017 21-07-48

*******************


다음 과제 ; 위 에러 확인 / 빌드 확립 / 두개의 프로젝트로 구분(나의 빌드/ 상대 빌드 )




2017.10.7
// 빌드 반복 좀더 확실하게
** 좀더 매끄러운 반복
ProductionManager 에 새로운 함수 추가.
기존의 setBuildOrder() 함수는 m_queue를 초기화 하여서 빌드가 꼬임.
새로운 renewBuildOrder() 함수는 초기화하지 않고 기존의 m_queue를 이어서 사용

ProductionManager.h
void    renewBuildOrder(const BuildOrder & buildOrder);

ProductionManager.cpp
// add
void ProductionManager::renewBuildOrder(const BuildOrder & buildOrder)
{	
	size_t i(m_queue.size());

	for (i; i<buildOrder.size(); ++i)
	{
		m_queue.queueAsLowestPriority(buildOrder[i], true);
	}
}

** 위처럼 수정하고 나니 위에서 발생했던 오류는 발생하지 않는다. 하지만 나중에라도 체크해야 됨.
BuildingManager의 분석은 나중에

** 빌드오더의 반복구문
BotConfig 파일에 LoopBuildOrder 태그 추가

StrategyManager.h 내 Strategy 구조체에 BuildOrder m_loopOrder 변수 추가
struct Strategy
{
    std::string m_name;
    sc2::Race   m_race;
    int         m_wins;
    int         m_losses;
    BuildOrder  m_buildOrder;
	BuildOrder	m_loopOrder;

    Strategy();
    Strategy(const std::string & name, const sc2::Race & race, const BuildOrder & buildOrder);
};

Strategy 구조체의 Constructur 개조
 Strategy(const std::string & name, const sc2::Race & race, const BuildOrder & buildOrder); 에서
 Strategy(const std::string & name, const sc2::Race & race, const BuildOrder & buildOrder, const BuildOrder & loopOrder);
loop BuildOrder 추가 , 그리고 이에 맞추어서 StrategyManager.cpp 파일들도 변경

==> readStrategyFile() 함수 내 마지막 전략추가함수
addStrategy(name, Strategy(name, strategyRace, buildOrde)); 에서 
addStrategy(name, Strategy(name, strategyRace, buildOrder, loopOrder)); 으로 변경

StrategyManager에 새로운 getLoopBookBuildOrder() 함수 생성
자세 내용
const BuildOrder & StrategyManager::getLoopBookBuildOrder() const
{
	auto buildOrderIt = m_strategies.find(m_bot.Config().StrategyName);

	// look for the build order in the build order map
	if (buildOrderIt != std::end(m_strategies))
	{
		return (*buildOrderIt).second.m_loopOrder;
	}
	else
	{
		BOT_ASSERT(false, "Strategy not found: %s, returning empty initial build order", m_bot.Config().StrategyName.c_str());
		return m_emptyBuildOrder;
	}
}
-->getOpeningBookBuildOrder() 함수에서 m_buildOrder 를 m_loopOrder로 변경만하면 된다.

==> ProductionManager.cpp
manageBuildOrderQueue() 내 만약 큐가 비었을 경우, 위에 맞추어서 변경
if (m_queue.isEmpty())
    {
		renewBuildOrder(m_bot.Strategy().getLoopBookBuildOrder());
        return;
    }

++ 나중에 m_queue.isEmpty()가 아닌, 큐가 조금 남아있을 경우 추가하는 방식으로 변경해야한다.
왜냐하면, 완전히 비면 새로 큐를 추가하는동안 생산이 멈춘다.

++ 공격 스쿼드를 하나로 구성한다면, 빈집이 들어오는 경우, 방어하기 위해 돌아온다.
이걸 전략적으로 사용할 수 있을 듯

//*** 오류 발생.
건물을 모두 부시기 직전? 자세히 확인은 못함
콘솔창에는 오류가 표시되지 않았는데, 게임이 중단됨
예상1. 게임이 종료되었는데, 다른 onFrame들이 계속 동작하려고해서 문제가 된거다.
